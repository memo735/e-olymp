#include <iostream>
#include <string.h>
#include <math.h>

using namespace std;

#define MAX 4000001
long n, d[MAX], fi[MAX];

//Функция FillEuler заполняет массив fi так что fi[i] = j(i), i < MAX.
void FillEuler()
{
	//Изначально положим значение fi[i] равным i.
	for (int i = 2; i < MAX; i++) fi[i] = i;

	//Каждое четное число i имеет простой делитель p = 2. Для ускорения работы функции обработаем его отдельно.
	//Для каждого четного i положим fi[i] = fi[i] * (1 – 1 / 2) = fi[i] / 2.
	for (int i = 2; i < MAX; i += 2) fi[i] /= 2;

	//Перебираем все возможные нечетные делители i = 3, 5, 7, … .
	for (int i = 3; i < MAX; i += 2)
		if (fi[i] == i)
			//Если fi[i] = i, то число i является простым. Число i является простым делителем
			//для всякого j, представимого в виде k * i для каждого натурального k.
			//Если i является простым делителем j, то положим fi(j) = fi(j) * (1 – 1 / i).
			for (int j = i; j < MAX; j += i) fi[j] -= fi[j] / i;
}

//Перед вызовом функции f значения d[i] уже содержит j(i). Тело функции f добавляет в d[j] значения так,
//чтобы в конце работы функции d[j] содержало sum(i=1..j-1) GCD(i,j) согласно формуле, приведенной в теореме.
void f()
{
	int i, SQRT_MAX = sqrt(1.0*MAX);
	for (i = 2; i <= SQRT_MAX; i++)
	{
		d[i*i] += i * fi[i];

		//В реализации можно избежать целочисленного деления. Для этого следует заметить, что поскольку значение
		//переменной j каждый раз увеличивается на i, то значение j / i будет увеличиваться в цикле на единицу.
		//Положим изначально k = j / i = (i * i + i) / i = i + 1 и далее при каждой итерации цикла будем увеличивать k на 1.
		for (int j = i * i + i, k = i + 1; j < MAX; j += i, k++) d[j] += i * fi[k] + k * fi[i];
	}
}

int main() {
	//Положим d[i] = j(i).
	memset(d, 0, sizeof d);
	FillEuler();
	memcpy(d, fi, sizeof fi);
	f();
	for (int i = 3; i < MAX; i++) d[i] += d[i - 1];
	while (scanf("%ld", &n), n) printf("%ld\n", d[n]);
	return 0;
}
